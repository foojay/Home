---
layout: post
title:  "GC问题"
date:   2017-03-11 13:27:00
categories: java
excerpt:  GC问题
---

* content
{:toc}




### 引用有哪些类型？

* 强引用：通过new创建出来的对象。只要强引用存在，垃圾回收器将不会回收。
* 软引用：通过SoftReference实现软引用,系统将要发生内存溢出之前才会对这些对象进行

回收。

* 弱引用：通过WeakReference实现弱引用，无论当内存足够，GC运行时都会进行回收。

* 虚引用：通过PhantomReference实现，通过虚引用无法回去对象的实例，虚引用的作用就

是当此对象被回收时，会收到一个系统通知

 

### 要进行垃圾回收，如何判断一个对象是否应该被回收？

* 引用计数算法：每当有一个地方引用他，就加1，引用失效，就减1.数量为0，说明可以进行回收。引用计数算法的缺点就是无法判断两个对象之间存在相互引用的情况。jvm中没有使用这种判断方式。
* 可达性分析算法：jvm中使用的时这种方式，通过一系列GCRoot对象作为起始点，从这些点开始向下搜索，搜索的路径成为引用链，当一个对象到GC没有任何引用链，说明对象可以被回收。

### GCRoot对象有哪些？

* 虚拟机栈的栈帧中引用的对象。
* 方法区中静态属性引用的对象。
* 方法区中常亮引用的对象。
* 本地方法栈中jni引用的对象。

### 对象不能够被回收，那是否可达性算法不可达的对象就一定会被回收？

不一定，当发现对象不可达的时候，将会对此对象进行第一次标记，对标记的对象就行筛

选，筛选的条件是是否有必要执行finalize()方法。

* 当此对象已经调用过finalize()方法或者在对象中没有覆盖finalize()方法，则判定次对象没有必要执行finalize()方法。
* 没有必要执行finalize()方法的对象将会直接被回收。
* 有必要执行finalize()方法的对象放在一个队列中，之后有虚拟机创建一个低优先级的线程去出发队列中的对象的finalize()方法，注意此处为触发并非等待finalize()执行结束，防止finalize()方法中出现死循环导致回收系统崩溃。
* 当一个对象的finalize()方法执行结束后，方法并没有被回收，稍后会对队列中的对象进行二次标记，此时标记的依据是对象是否可达。如果还是不可达，才会将此对象放入即将回收的集合。所以finalize()方法中如果为对象添加引用链，可以拯救此对象。
注意：每个对象的finalize()方法只会被jvm调用一次，如果一个对象在第一次执行finalize()时候被拯救，在下次执行回收会直接对对象就行回收，将不会调用对象的finalize()方法。


### 方法区中所谓的回收无用的类，那什么样的类会被判定为无用的类？

* java堆中不存在该类的任何实例。    
* 加载该类的ClassLoader已经被回收。
* 该类的class对象没有任何地方被引用。

满足以上三个条件的类可以被回收，而不是和java堆中的对象一样必然会被回收。 


### 垃圾收集器是如何对堆内存进行划分的呢？

一般将堆内存分为新生代和老年代，新生代又分为一块较大的Eden和两块较小的Survivor

区域(HotSpot虚拟机E:S=8:1)。

新生的对象优先分配在新生代的E区，如果启用本地线程缓冲，优先在TLAB上进行分配，少

数情况也会直接在老年代进行对象的分配，在以下几种情况下，对象会转入老年代。

* 当在E分配对象发现内存不够使用的时候，会发生新生代的GC将E区对象转入S区，当发现S区无法存放时，通过分配担保将对象转入老年代。
* 大对象直接进入老年代(阀值可以通过参数进行设定)，为了避免E区和S区之间发生大量的内存复制。
* 长期存活的对象进入老年代，虚拟机给每个对象定义了一个年龄计数器，在E区中的对象经过一次GC仍然存活并能够被S区容纳，设置此对象的年龄为1，在S区中的对象，每熬过一次GC，就将年龄加1，当年龄达到一定的程度(默认是15，可以通过参数进行设置)就会进入老年代。
* 动态年龄判断，不一定只有年龄达到阀值才会进入老年代，当相同年龄的对象的总大小大于S空间的一半，则大于等于这个年龄的对象将会进入老年代。


### 什么是空间分配担保？

当新生代发生GC的时候，先判断老年代中的剩余空间的总大小是否大于新生代中的总对象

的大小，如果是，则发生进行新生代的GC，如果不是，则判断是否允许担保失败（可以通

过HandlePromotionFailure进行设置），如果不允许，则进行老年代的GC,如果允许，则判

断老年代中的剩余空间的总大小是否大于新生代每次发生GC时进入老年代的对象的平均值

，如果是，则进行新生代的GC，如果不是，则进行一次老年代的GC。在担保失败的情况下

会进行FULL GC，如果担保失败，判断平均值使得多了一次计算，但是计算均值担保是有必

要的，他可以是为了防止进行频繁的老年代GC。


### 垃圾回收算法有那些？


* 标记-清除：标记所有需要被回收的对象，然后回收。次算法效率低，并且产生内存碎片，由于老年代中存活的对象多，在老年代中进行使用。
* 复制算法：将内存划分为等大小的两块，每次使用其中的一块，回收时，将存活的对象复制到没有使用的一块内存中，然后对使用的内存一次性就行清理。实现简单，运行高效，但是存在大量内存的浪费。由于新生代中存活的对象少，新生代中使用这种算法将E区存活的对象复制到S区。
* 标记整理算法：让所有存活的对象往一侧移动，然后清楚另一侧。在老年代中使用这种算法，避免产生内存碎片




