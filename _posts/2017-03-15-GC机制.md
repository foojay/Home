---
layout: post
title:  "GC机制"
date:   2017-03-15 14:27:00
categories: java
excerpt:  GC机制
---

* content
{:toc}




### 概述

GC，即就是Java垃圾回收机制。目前主流的JVM（HotSpot）采用的是分代收集算法。与C++

不同的是，Java采用的是类似于树形结构的可达性分析法来判断对象是否还存在引用。即

：从gcroot开始，把所有可以搜索得到的对象标记为存活对象。

### GC机制

要准确理解Java的垃圾回收机制，就要从：“什么时候”，“对什么东西”，“做了什么”三个

方面来具体分析。

第一：“什么时候”即就是GC触发的条件。GC触发的条件有两种。（1）程序调用System.

gc时可以触发；（2）系统自身来决定GC触发的时机。

系统判断GC触发的依据：根据Eden区和From 

Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程。

第二：“对什么东西”笼统的认为是Java对象并没有错。但是准确来讲，GC操作的对象分为

：通过可达性分析法无法搜索到的对象和可以搜索到的对象。对于搜索不到的方法进行标

记。

第三：“做了什么”最浅显的理解为释放对象。但是从GC的底层机制可以看出，对于可以搜

索到的对象进行复制操作，对于搜索不到的对象，调用finalize()方法进行释放。

具体过程：当GC线程启动时，会通过可达性分析法把Eden区和From 

Space区的存活对象复制到To Space区，然后把Eden Space和From 

Space区的对象释放掉。当GC轮训扫描To 

Space区一定次数后，把依然存活的对象复制到老年代，然后释放To Space区的对象。

对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，

至少需要经过两次标记的过程。

    第一次标记：对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()
    方法，如果没有执行必要，则意味可直接回收。（筛选依据：是否复写或执行过finalize(
    )方法；因为finalize方法只能被执行一次）。
    第二次标记：如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优
    先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象
    会被移除FQueue队列。

![GC](http://i66.tinypic.com/21n1qu9.jpg)