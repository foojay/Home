---
layout: post
title:  "GC问题"
date:   2017-03-11 13:27:00
categories: java
excerpt:  GC问题
---

* content
{:toc}



### 垃圾收集器有哪些?

* 新生代收集器：Serial、ParNew、Parallel Scavenge；

* 老年代收集器：Serial Old、Parallel Old、CMS；

* 整堆收集器：G1；

（A）、并行（Parallel）

指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；

如ParNew、Parallel Scavenge、Parallel Old；

（B）、并发（Concurrent）

指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）；

用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；    

如CMS、G1（也有并行）




### 引用有哪些类型？

* 强引用：通过new创建出来的对象。只要强引用存在，垃圾回收器将不会回收。
* 软引用：通过SoftReference实现软引用,系统将要发生内存溢出之前才会对这些对象进行

回收。

* 弱引用：通过WeakReference实现弱引用，无论当内存足够，GC运行时都会进行回收。

* 虚引用：通过PhantomReference实现，通过虚引用无法回去对象的实例，虚引用的作用就

是当此对象被回收时，会收到一个系统通知

 

### 要进行垃圾回收，如何判断一个对象是否应该被回收？

* 引用计数算法：每当有一个地方引用他，就加1，引用失效，就减1.数量为0，说明可以进行回收。引用计数算法的缺点就是无法判断两个对象之间存在相互引用的情况。jvm中没有使用这种判断方式。
* 可达性分析算法：jvm中使用的时这种方式，通过一系列GCRoot对象作为起始点，从这些点开始向下搜索，搜索的路径成为引用链，当一个对象到GC没有任何引用链，说明对象可以被回收。

### GCRoot对象有哪些？

* 虚拟机栈的栈帧中引用的对象。
* 方法区中静态属性引用的对象。
* 方法区中常亮引用的对象。
* 本地方法栈中jni引用的对象。

### 对象不能够被回收，那是否可达性算法不可达的对象就一定会被回收？

不一定，当发现对象不可达的时候，将会对此对象进行第一次标记，对标记的对象就行筛

选，筛选的条件是是否有必要执行finalize()方法。

* 当此对象已经调用过finalize()方法或者在对象中没有覆盖finalize()方法，则判定次对象没有必要执行finalize()方法。
* 没有必要执行finalize()方法的对象将会直接被回收。
* 有必要执行finalize()方法的对象放在一个队列中，之后有虚拟机创建一个低优先级的线程去出发队列中的对象的finalize()方法，注意此处为触发并非等待finalize()执行结束，防止finalize()方法中出现死循环导致回收系统崩溃。
* 当一个对象的finalize()方法执行结束后，方法并没有被回收，稍后会对队列中的对象进行二次标记，此时标记的依据是对象是否可达。如果还是不可达，才会将此对象放入即将回收的集合。所以finalize()方法中如果为对象添加引用链，可以拯救此对象。
注意：每个对象的finalize()方法只会被jvm调用一次，如果一个对象在第一次执行finalize()时候被拯救，在下次执行回收会直接对对象就行回收，将不会调用对象的finalize()方法。


### 方法区中所谓的回收无用的类，那什么样的类会被判定为无用的类？

* java堆中不存在该类的任何实例。    
* 加载该类的ClassLoader已经被回收。
* 该类的class对象没有任何地方被引用。

满足以上三个条件的类可以被回收，而不是和java堆中的对象一样必然会被回收。 


### 垃圾收集器是如何对堆内存进行划分的呢？

一般将堆内存分为新生代和老年代，新生代又分为一块较大的Eden和两块较小的Survivor

区域(HotSpot虚拟机E:S=8:1)。

新生的对象优先分配在新生代的E区，如果启用本地线程缓冲，优先在TLAB上进行分配，少

数情况也会直接在老年代进行对象的分配，在以下几种情况下，对象会转入老年代。

* 当在E分配对象发现内存不够使用的时候，会发生新生代的GC将E区对象转入S区，当发现S区无法存放时，通过分配担保将对象转入老年代。
* 大对象直接进入老年代(阀值可以通过参数进行设定)，为了避免E区和S区之间发生大量的内存复制。
* 长期存活的对象进入老年代，虚拟机给每个对象定义了一个年龄计数器，在E区中的对象经过一次GC仍然存活并能够被S区容纳，设置此对象的年龄为1，在S区中的对象，每熬过一次GC，就将年龄加1，当年龄达到一定的程度(默认是15，可以通过参数进行设置)就会进入老年代。
* 动态年龄判断，不一定只有年龄达到阀值才会进入老年代，当相同年龄的对象的总大小大于S空间的一半，则大于等于这个年龄的对象将会进入老年代。


### 什么是空间分配担保？

当新生代发生GC的时候，先判断老年代中的剩余空间的总大小是否大于新生代中的总对象

的大小，如果是，则发生进行新生代的GC，如果不是，则判断是否允许担保失败（可以通

过HandlePromotionFailure进行设置），如果不允许，则进行老年代的GC,如果允许，则判

断老年代中的剩余空间的总大小是否大于新生代每次发生GC时进入老年代的对象的平均值

，如果是，则进行新生代的GC，如果不是，则进行一次老年代的GC。在担保失败的情况下

会进行FULL GC，如果担保失败，判断平均值使得多了一次计算，但是计算均值担保是有必

要的，他可以是为了防止进行频繁的老年代GC。


### 垃圾回收算法有那些？

* 复制算法：将内存划分为等大小的两块，每次使用其中的一块，回收时，将存活的对象复制到没有使用的一块内存中，然后对使用的内存一次性就行清理。实现简单，运行高效，但是存在大量内存的浪费。由于新生代中存活的对象少，新生代中使用这种算法将E区存活的对象复制到S区。
* 标记-清除：标记所有需要被回收的对象，然后回收。次算法效率低，并且产生内存碎片,由于老年代中存活的对象多，在老年代中进行使用。
* 标记整理算法：让所有存活的对象往一侧移动，然后清楚另一侧。在老年代中使用这种算法，避免产生内存碎片


### 吞吐量

CPU用于运行用户代码的时间与CPU总消耗时间的比值；

即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）；    

高吞吐量即减少垃圾收集时间，让用户代码获得更长的运行时间；


### CMS收集器运作过程



* （A）、初始标记（CMS initial mark）

仅标记一下GC Roots能直接关联到的对象；

速度很快；

但需要"Stop The World"；

* （B）、并发标记（CMS concurrent mark）

进行GC Roots Tracing的过程；

刚才产生的集合中标记出存活对象；

应用程序也在运行；

并不能保证可以标记出所有的存活对象；

* （C）、重新标记（CMS remark）

为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录；

需要"Stop The World"，且停顿时间比初始标记稍长，但远比并发标记短；

采用多线程并行执行来提升效率；

* （D）、并发清除（CMS concurrent sweep）

回收所有的垃圾对象；

整个过程中耗时最长的并发标记和并发清除都可以与用户线程一起工作；

所以总体上说，CMS收集器的内存回收过程与用户线程一起并发执行；

![](http://i63.tinypic.com/111v90i.jpg)


CMS收集器3个明显的缺点:

（A）、对CPU资源非常敏感

并发收集虽然不会暂停用户线程，但因为占用一部分CPU资源，还是会导致应用程序变慢，

总吞吐量降低。

CMS的默认收集线程数量是=(CPU数量+3)/4；

当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个

时，影响更大，可能无法接受。

（B）、无法处理浮动垃圾,可能出现"Concurrent Mode Failure"失败


（C）、产生大量内存碎片

 由于CMS基于"标记-清除"算法，清除后不进行压缩操作；



 ### G1收集器


用来替换掉JDK1.5中的CMS收集器；

在下面的情况时，使用G1可能比CMS好：

（1）、超过50％的Java堆被活动数据占用；

（2）、对象分配频率或年代提升频率变化很大；

（3）、GC停顿时间过长（长于0.5至1秒）。

是否一定采用G1呢？也未必：

 如果现在采用的收集器没有出现问题，不用急着去选择G1；

如果应用程序追求低停顿，可以尝试选择G1；

是否代替CMS需要实际场景测试才知道。




 * [原文出处](https://blog.csdn.net/tjiyu/article/details/53983650)



